# 比特币的总数为何是两千一百万(21000000)个？

[返回目录](../index.md)

比特币系统有一些预置规则([Ref](https://en.bitcoin.it/wiki/Protocol_rules))：

1. 系统一开始，每个区块奖励50BTC
2. 每隔2016个区块调整挖矿难度，使出块时间维持在10分钟左右
3. 每隔二十一万(210000)个区块，奖励减半
4. 所有比特币最初的来源都是区块奖励

这些预置规则是比特币世界的「公理」，比特币的总数量可以通过它们得出。

我们通过计算区块奖励的总和便可以得到比特币的总数

- 最初的210000个区块每块奖励50BTC
- 接下来的210000个区块每块奖励25BTC
- 接下来的210000个区块每块奖励12.5BTC
- 接下来的210000个区块每块奖励6.25BTC
- ...

所以总的区块奖励是：

$$
\begin{equation}
    \begin{split}  
& \hspace{1.25 em} 50 \times 21000
+ 50 \times \dfrac{1}{2} \times 21000
+ 50 \times \dfrac{1}{2^2} \times 21000
+ 50 \times \dfrac{1}{2^3} \times 21000
+ ... \nonumber \\
&= 50 \times 21000 \times \left(1 + \dfrac{1}{2} + \dfrac{1}{2^2} + \dfrac{1}{2^3} + \cdots\right) \\
&= 50 \times 21000 \times \lim_{n \to \infty} \dfrac{1 - \left(\dfrac{1}{2}\right)^n}{1 - \dfrac{1}{2}} \\
&= 50 \times 21000 \times 2 \\
&= 21000000
    \end{split}
\end{equation}
$$

## 附一，查看和验证区块奖励

区块接入区块链的顺序，叫做「高度」，从0开始。所以前210000个区块对应的高度值是从0到209999, 其余以此类推。

| 区块高度         | 区块奖励(BTC) | 起始时间(UTC+0800)  |   结束时间(UTC+0800)  | 起始区块 | 结束区块 |
|------------------|---------------|----------|----------|-----------------------------------------------|------------------|
| 0 ~ 209999       | 50            | 2009-01-04 02:15:05 | 2012-11-28 23:01:40 | [000000000019d6689c085a...6f](https://mempool.space/block/000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f) | [00000000000000f3819164...e1](https://mempool.space/block/00000000000000f3819164645360294b5dee7f2e846001ac9f41a70b7a9a3de1) |
| 210000 ~ 419999  | 25            | 2012-11-28 23:24:38 | 2016-05-09 21:56:18 | [000000000000048b95347e...2e](https://mempool.space/block/000000000000048b95347e83192f69cf0366076336c639f9b7228e9ba171342e) | [0000000000000000036f6f...ab](https://mempool.space/block/0000000000000000036f6fc4b804b05a6b79b2d5eb84cfef4674de2ef1eb83ab) |
| 420000 ~ 629999  | 12            | 2016-07-10 00:46:13 | 2020-05-12 03:23:23 | [000000000000000002cce8...a1](https://mempool.space/block/000000000000000002cce816c0ab2c5c269cb081896b7dcb34b8422d6b74ffa1) | [0000000000000000000d65...1e](https://mempool.space/block/0000000000000000000d656be18bb095db1b23bd797266b0ac3ba720b1962b1e) |
| 630000 ~ 839999  | 6.25          | 2020-05-12 03:23:43 |  (2024.04)          | [000000000000000000024b...6d](https://mempool.space/block/000000000000000000024bead8df69990852c202db0e0097c1a12ea637d7e96d) | |
| 840000 ~ 1049999 | 3.125         |  (2024.04)          |  (2028)             |  |  |


通过这张表也能看出每次奖励维持的时间大约是4年，因为过了这段时间之后，区块奖励会减半，所以一般也称「比特币的减半周期是4年」。中本聪预想的是每10种产生一个新的区块，但现实世界中矿机的运算能力是变动的，如果算力高，可能很快就能生成一个满足条件的区块，反之，超过10分钟也不一定能生成符合条件的区块。为了应对这种情况，中本聪设计了一个调节机制——每2016个区块后调整挖矿难度，如果前面生成区块太快，就提升难度降速，反之则降低难度。这就保证了生成区块的时间间隔大致在10分钟左右。我们假设现实中也是10分钟生成一个区块，则能计算出

- 10 min * 2016 = 20160 min = 20160 / 60 h = 336 h = 14 day = 2 week 也就是每两周调整一次挖矿难度
- 10 min * 210000 = 2100000 min = 2100000 / 60 h = 35000 h = 1458.333333 day = 4 year 也就是每4年挖矿的奖励减半

通过这张表还课可以看到区块的 hash 值开头的0有越来越多的趋势，这反应了挖矿的难度随着时间的推移在增加。

注：

通过区块高度查区块的 hash 的方法。打开 Bitcoin Core Wallet，菜单路径是 Window -> Console, 再在命令行界面执行 `getblockhash {height}` 即可，如查看第一个区块和高度为630000的区块，可以通过下面的指令完成：

```plaintext
getblockhash 0
000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f
getblockhash 630000
000000000000000000024bead8df69990852c202db0e0097c1a12ea637d7e96d
```

如果查询还未产生的区块，会报错，如：

```plaintext
getblockhash 840000
Block height out of range (code -8)
```

已知区块的 hash 值，就可以在 <https://mempool.space> 上查到它比较详细的信息，如 <https://mempool.space/block/000000000000000000024bead8df69990852c202db0e0097c1a12ea637d7e96d>


## 附二，等比数列的求和公式

如果一个数列，从第二项起每项对它的前项的比是一样的，这个数列就是等比数列。假设有一个数列

$a_1, a_2, a_3, ..., a_{n-1}, a_n$ 满足 $\dfrac{a_2}{a_1} = \dfrac{a_3}{a_2} = \cdots =\dfrac{a_n}{a_{n-1}}$

则它为等比数列。不妨设

$q = \dfrac{a_2}{a_1}$

$q$ 一般称为这个等比数列的公比。

如此数列也可以表示为

$a_1, a_1q, a_1q^2, ..., a_{1}q^{n-2}, a_{1}q^{n-1}$

数列的和可以直接表示为：

$S_n = a_{1}(1+q+q^2+\cdots+q^{n-2}+q^{n-1})$ -- (1)

两边同时乘以公比 $q$ 得

$qS_n = a_{1}(q+q^2+\cdots+q^{n-2}+q^{n-1}+q^{n})$ -- (2)

上面两式相减，(1) - (2)，得

$(1-q)S_n = a_{1}(1-q^{n})$

所以，当 $q \neq 1$ 时

$S_n = a_{1}\dfrac{1-q^{n}}{1-q}$

而当 $q = 1$ 时

$S_n = na_{1}$

以上最后两个式子就是这个等比数列的求和公式。

<script>
MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']]
  }
};
</script>
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
</script>
